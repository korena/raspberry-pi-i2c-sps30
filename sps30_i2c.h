/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * Generator:     sensirion-driver-generator 1.3.3
 * Product:       sps30
 * Model-Version: 1.0.1
 */
/*
 * Copyright (c) 2025, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SPS30_I2C_H
#define SPS30_I2C_H

#ifdef __cplusplus
extern "C" {
#endif

#include "sensirion_config.h"
#define SPS30_I2C_ADDR_69 0x69

typedef enum {
    SPS30_START_MEASUREMENT_CMD_ID = 0x10,
    SPS30_STOP_MEASUREMENT_CMD_ID = 0x104,
    SPS30_READ_DATA_READY_FLAG_CMD_ID = 0x202,
    SPS30_READ_MEASUREMENT_VALUES_UINT16_CMD_ID = 0x300,
    SPS30_READ_MEASUREMENT_VALUES_FLOAT_CMD_ID = 0x300,
    SPS30_SLEEP_CMD_ID = 0x1001,
    SPS30_WAKE_UP_CMD_ID = 0x1103,
    SPS30_START_FAN_CLEANING_CMD_ID = 0x5607,
    SPS30_READ_AUTO_CLEANING_INTERVAL_CMD_ID = 0x8004,
    SPS30_WRITE_AUTO_CLEANING_INTERVAL_CMD_ID = 0x8004,
    SPS30_READ_PRODUCT_TYPE_CMD_ID = 0xd002,
    SPS30_READ_SERIAL_NUMBER_CMD_ID = 0xd033,
    SPS30_READ_FIRMWARE_VERSION_CMD_ID = 0xd100,
    SPS30_READ_DEVICE_STATUS_REGISTER_CMD_ID = 0xd206,
    SPS30_CLEAR_DEVICE_STATUS_REGISTER_CMD_ID = 0xd210,
    SPS30_DEVICE_RESET_CMD_ID = 0xd304,
} SPS30_CMD_ID;

typedef enum {
    SPS30_OUTPUT_FORMAT_OUTPUT_FORMAT_FLOAT = 768,
    SPS30_OUTPUT_FORMAT_OUTPUT_FORMAT_UINT16 = 1280,
} sps30_output_format;

/**
 * @brief Initialize i2c address of driver
 *
 * @param[in] i2c_address Used i2c address
 *
 */
void sps30_init(uint8_t i2c_address);

/**
 * @brief Fully wake up the device
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_wake_up_sequence();

/**
 * @brief Start measurement
 *
 * Starts the measurement. After power up, the module is in Idle-Mode. Before
 * any measurement values can be read, the Measurement-Mode needs to be started
 * using this command.
 *
 * @param[in] measurement_output_format Possible enum values:
 * output_format_float, output_format_uint16
 *
 * @note This command can only be executed in Idle-Mode.
 *
 * @return error_code 0 on success, an error code otherwise.
 *
 * Example:
 * --------
 *
 * @code{.c}
 *
 *     int16_t local_error = 0;
 *     local_error = sps30_start_measurement((sps30_output_format)(1280));
 *     if (local_error != NO_ERROR) {
 *         return local_error;
 *     }
 *
 * @endcode
 *
 */
int16_t sps30_start_measurement(sps30_output_format measurement_output_format);

/**
 * @brief Stop measurement
 *
 * Use this command to return to the Idle-Mode.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_stop_measurement();

/**
 * @brief Read data ready flag
 *
 * This command can be used for polling to find out when new measurements are
 * available. The pointer address only has to be set once. Repeated read
 * requests get the status of the Data-Ready Flag.
 *
 * @param[out] data_ready_flag 0x0000: no new measurements available 0x0001: new
 * measurements ready to read
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_data_ready_flag(uint16_t* data_ready_flag);

/**
 * @brief Read measurement values
 *
 * Reads the measured values from the sensor module and resets the “Data-Ready
 * Flag”. If the sensor module is in Measurement-Mode, an updated measurement
 * value is provided every second and the “Data-Ready Flag” is set. If no
 * synchronized readout is desired, the “Data-Ready Flag” can be ignored. The
 * command “Read Measured Values” always returns the latest measured values.
 *
 * @param[out] mc_1p0 Mass Concentration PM1.0 [µg/m³]
 * @param[out] mc_2p5 Mass Concentration PM2.5 [µg/m³]
 * @param[out] mc_4p0 Mass Concentration PM4.0 [µg/m³]
 * @param[out] mc_10p0 Mass Concentration PM10.0 [µg/m³]
 * @param[out] nc_0p5 Number Concentration PM0.5 [#/cm³]
 * @param[out] nc_1p0 Number Concentration PM1.0 [#/cm³]
 * @param[out] nc_2p5 Number Concentration PM2.5 [#/cm³]
 * @param[out] nc_4p0 Number Concentration PM4.0 [#/cm³]
 * @param[out] nc_10p0 Number Concentration PM10.0 [#/cm³]
 * @param[out] typical_particle_size Typical Particle Size [µm]
 *
 * @note Use this function when the measurement output format is configured to:
 * "Big-endian unsigned 16-bit integer values"
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_measurement_values_uint16(
    uint16_t* mc_1p0, uint16_t* mc_2p5, uint16_t* mc_4p0, uint16_t* mc_10p0,
    uint16_t* nc_0p5, uint16_t* nc_1p0, uint16_t* nc_2p5, uint16_t* nc_4p0,
    uint16_t* nc_10p0, uint16_t* typical_particle_size);

/**
 * @brief Read measurement values
 *
 * Reads the measured values from the sensor module and resets the “Data-Ready
 * Flag”. If the sensor module is in Measurement-Mode, an updated measurement
 * value is provided every second and the “Data-Ready Flag” is set. If no
 * synchronized readout is desired, the “Data-Ready Flag” can be ignored. The
 * command “Read Measured Values” always returns the latest measured values.
 *
 * @param[out] mc_1p0 Mass Concentration PM1.0 [µg/m³]
 * @param[out] mc_2p5 Mass Concentration PM2.5 [µg/m³]
 * @param[out] mc_4p0 Mass Concentration PM4.0 [µg/m³]
 * @param[out] mc_10p0 Mass Concentration PM10.0 [µg/m³]
 * @param[out] nc_0p5 Number Concentration PM0.5 [#/cm³]
 * @param[out] nc_1p0 Number Concentration PM1.0 [#/cm³]
 * @param[out] nc_2p5 Number Concentration PM2.5 [#/cm³]
 * @param[out] nc_4p0 Number Concentration PM4.0 [#/cm³]
 * @param[out] nc_10p0 Number Concentration PM10.0 [#/cm³]
 * @param[out] typical_particle_size Typical Particle Size [µm]
 *
 * @note Use this function when the measurement output format is configured to:
 * "Big-endian IEEE754 float values"
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_measurement_values_float(float* mc_1p0, float* mc_2p5,
                                            float* mc_4p0, float* mc_10p0,
                                            float* nc_0p5, float* nc_1p0,
                                            float* nc_2p5, float* nc_4p0,
                                            float* nc_10p0,
                                            float* typical_particle_size);

/**
 * @brief Enter Sleep-Mode
 *
 * Enters the Sleep-Mode with minimum power consumption. This will also
 * deactivate the I2C interface.
 *
 * @note This command can only be executed in Idle-Mode.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_sleep();

/**
 * @brief Switch from Sleep-Mode to Idle-Mode
 *
 * In Sleep-Mode the I2C interface is disabled and must first be activated by
 * sending a low pulse on the SDA line. A low pulse can be generated by sending
 * a I2C-Start-Condition followed by a Stop-Condition. If then a Wake-up command
 * follows within 100ms, the module will switch on again and is ready for
 * further commands in the Idle-Mode. If the low pulse is not followed by the
 * Wake-up command, the microcontroller returns after 100ms to Sleep-Mode and
 * the interface is deactivated again.
 *
 * Alternatively, if the software implementation does not allow to send a
 * I2C-Start-Condition followed by a Stop-Condition, the Wake-up command can be
 * sent twice in succession. In this case the first Wake-up command is ignored,
 * but causes the interface to be activated.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_wake_up();

/**
 * @brief Starts fan cleaning manually
 *
 * @note This command can only be executed in Measurement-Mode.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_start_fan_cleaning();

/**
 * @brief Reads auto cleaning interval of the periodic fan-cleaning
 *
 * @param[out] auto_cleaning_interval Interval in seconds
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_auto_cleaning_interval(uint32_t* auto_cleaning_interval);

/**
 * @brief Writes auto cleaning interval of the periodic fan-cleaning
 *
 * @param[in] auto_cleaning_interval Interval in seconds
 *
 * @note For FW Version < 2.2: After writing a new interval, this will be
 * activated immediately. However, if the interval register is read out after
 * setting the new value, the previous value is returned until the next
 * start/reset of the sensor module.
 *
 * @return error_code 0 on success, an error code otherwise.
 *
 * Example:
 * --------
 *
 * @code{.c}
 *
 *     int16_t local_error = 0;
 *     local_error = sps30_write_auto_cleaning_interval(604800);
 *     if (local_error != NO_ERROR) {
 *         return local_error;
 *     }
 *
 * @endcode
 *
 */
int16_t sps30_write_auto_cleaning_interval(uint32_t auto_cleaning_interval);

/**
 * @brief Read product type
 *
 * This command returns the product type. It is defined as a string value with a
 * length of 8 ASCII characters (excluding terminating null-character)
 *
 * @param[out] product_type 8-byte ASCII string
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_product_type(int8_t* product_type,
                                uint16_t product_type_size);

/**
 * @brief Read serial number
 *
 * This command returns the serial number. It is defined as a string value with
 * a maximum length of 32 ASCII characters (including terminating
 * null-character)
 *
 * @param[out] serial_number 32-byte ASCII string
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_serial_number(int8_t* serial_number,
                                 uint16_t serial_number_size);

/**
 * @brief Gets firmware major.minor firmware version.
 *
 * @param[out] major_version
 * @param[out] minor_version
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_firmware_version(uint8_t* major_version,
                                    uint8_t* minor_version);

/**
 * @brief Reads device status register
 *
 * Use this command to read the device status register. For more details, check
 * explanations given in chapter 4.4 of the datasheet.
 *
 * @param[out] device_status
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_device_status_register(uint32_t* device_status);

/**
 * @brief Clears the device status register.
 *
 * Use this command to clear the device status register. For more details, check
 * explanations given in chapter 4.4 of the datasheet.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_clear_device_status_register();

/**
 * @brief Device software reset
 *
 * Device software reset command. After calling this command, the module is in
 * the same state as after a power reset.
 *
 * @note To perform a reset when the sensor is in sleep mode, it is required to
 * send first a wake-up sequence to activate the interface.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_device_reset();

#ifdef __cplusplus
}
#endif
#endif  // SPS30_I2C_H
